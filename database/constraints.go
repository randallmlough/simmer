package database

// Constraint represents a constraint in a database
type Constraint struct {
	Name           string  `json:"name"`
	ConstraintType string  `json:"constraint_type"`
	ColumnName     string  `json:"column_name"`
	Type           string  `json:"type"`
	Nullable       bool    `json:"nullable"`
	Unique         bool    `json:"unique"`
	Sequenced      bool    `json:"sequenced"`
	AutoGenerated  bool    `json:"auto_generated"`
	ColumnDefault  *string `json:"column_default"`
}

type ConstraintList []Constraint

func (cl ConstraintList) PrimaryKey() *PrimaryKey {
	var pk *PrimaryKey
	for _, con := range cl {
		if con.ConstraintType == "PRIMARY KEY" {
			pk = &PrimaryKey{
				Name:      con.ColumnName,
				Columns:   []string{con.ColumnName},
				Sequenced: con.Sequenced,
			}
		}
	}
	return pk
}

func (cl ConstraintList) Uniques() ConstraintList {
	var cons []Constraint
	for _, con := range cl {
		if con.ConstraintType == "UNIQUE" {
			cons = append(cons, con)
		}
	}
	return cons
}

func (cl ConstraintList) Checks() ConstraintList {
	var cons []Constraint
	for _, con := range cl {
		if con.ConstraintType == "CHECK" {
			cons = append(cons, con)
		}
	}
	return cons
}

func (cl ConstraintList) AllRequired() ConstraintList {
	var cons []Constraint
	for _, con := range cl {
		if !con.Nullable && con.ConstraintType != "CHECK" {
			cons = append(cons, con)
		}
	}
	return cons
}

func (cl ConstraintList) AllIndexed() ConstraintList {
	var cons []Constraint
	for _, con := range cl {
		if con.ConstraintType != "CHECK" {
			cons = append(cons, con)
		}
	}
	return cons
}

// Constraint takes a column name and attempts to retrieve the constraint from the tables constraints
// If no constraint is found it will return an empty Constraint and false indicating one hasn't been found
func (cl ConstraintList) Constraint(columnName string) (Constraint, bool) {
	for _, con := range cl {
		if con.ColumnName == columnName {
			return con, true
		}
	}
	return Constraint{}, false
}
