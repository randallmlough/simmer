package config

import (
	"encoding/json"
	"fmt"
	"github.com/pkg/errors"
	"github.com/randallmlough/simmer/core"
	"github.com/randallmlough/simmer/utils"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var (
	noEditDisclaimerFmt = `// Code generated by Simmer%s(https://github.com/randallmlough/simmer). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

`
)

func LoadConfig(pathToConfigFile string) (*core.Config, error) {
	config, err := ReadConfigFile(pathToConfigFile)
	if err != nil {
		return nil, err
	}
	if len(config.Version) > 0 {
		config.NoEditDisclaimer = []byte(
			fmt.Sprintf(noEditDisclaimerFmt, " "+config.Version+" "),
		)
	}

	importPath, err := utils.RootImportPath()
	if err != nil {
		return nil, err
	}
	config.RootImportPath = importPath
	return config, nil
}

// Load returns Configuration struct
func ReadConfigFile(path string) (*core.Config, error) {
	ext := filepath.Ext(path)
	switch ext {
	case ".json", ".yaml", ".yml":
	default:
		return nil, errors.New("unsupported file. Config only supports: .json .yaml .yml")
	}
	bytes, err := readFileEnvParsing(path)
	if err != nil {
		return nil, errors.Wrap(err, "error reading config file")
	}
	var cfg = new(core.Config)
	switch ext {
	case ".json":
		if err := json.Unmarshal(bytes, cfg); err != nil {
			return nil, errors.Wrap(err, "unable to decode into struct")
		}
	case ".yaml", ".yml":
		if err := yaml.Unmarshal(bytes, cfg); err != nil {
			return nil, errors.Wrap(err, "unable to decode into struct")
		}
	}
	return cfg, nil
}

func readFileEnvParsing(path string) ([]byte, error) {
	confContent, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	// expand environment variables
	return []byte(os.Expand(string(confContent), ParseEnv)), nil
}

func ParseEnv(key string) string {
	parts := strings.Split(key, ":-")
	if env, ok := os.LookupEnv(parts[0]); ok {
		return env
	} else if len(parts) > 1 {
		return parts[1]
	}
	return ""
}
