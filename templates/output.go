package templates

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"github.com/pkg/errors"
	"github.com/randallmlough/simmer/importers"
)

var (
	noEditDisclaimerFmt = `// Code generated by Simmer%s(https://github.com/randallmlough/simmer). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

`
	noEditDisclaimer = []byte(fmt.Sprintf(noEditDisclaimerFmt, " "))
)

var (
	// templateByteBuffer is re-used by all template construction to avoid
	// allocating more memory than is needed. This will later be a problem for
	// concurrency, address it then.
	templateByteBuffer = &bytes.Buffer{}

	rgxRemoveNumberedPrefix = regexp.MustCompile(`^[0-9]+_`)
	rgxSyntaxError          = regexp.MustCompile(`(\d+):\d+: `)

	testHarnessWriteFile = ioutil.WriteFile
)

func Render(opts Options) error {

	if opts.OutFolder == "" {
		return errors.New("output dir is required")
	}

	if opts.PkgName == "" {
		opts.PkgName = filepath.Base(opts.OutFolder)
	}

	if !opts.IsSingleton {
		return executeTemplates(opts)
	} else {
		return executeSingletonTemplates(opts)
	}
}

func RenderSingleton(opts Options) error {
	opts.IsSingleton = true
	if err := Render(opts); err != nil {
		return errors.Wrap(err, "failed to render singleton")
	}
	return nil
}

type Options struct {
	Filename          string
	OutFolder         string
	NoGeneratedHeader bool
	PkgName           string
	Data              interface{}

	Wipe          bool
	Templates     []LazyTemplate
	TemplateFuncs TemplateFuncs

	ImportSet      importers.Set
	ImportNamedSet importers.Map

	IsTest      bool
	IsSingleton bool
}

func executeTemplates(e Options) error {

	if e.OutFolder == "" {
		return errors.New("output dir is required")
	}

	if e.PkgName == "" {
		e.PkgName = filepath.Base(e.OutFolder)
	}
	if err := initOutFolders(e.Templates, e.OutFolder, e.Wipe); err != nil {
		return errors.Wrap(err, "failed to initialize output folders")
	}

	templates, err := ParseTemplates(e.Templates, e.IsTest, e.TemplateFuncs)
	if err != nil {
		return err
	}

	for dir, dirExts := range groupTemplates(templates) {
		for ext, tplNames := range dirExts {
			out := templateByteBuffer
			out.Reset()

			isGo := filepath.Ext(ext) == ".go"
			if isGo {
				pkgName := e.PkgName
				if len(dir) != 0 {
					pkgName = filepath.Base(dir)
				}
				if !e.NoGeneratedHeader {
					writeFileDisclaimer(out)
				}
				writePackageName(out, pkgName)
				writeImports(out, e.ImportSet)
			}

			for _, tplName := range tplNames {

				if err := executeTemplate(out, templates.Template, tplName, e.Data); err != nil {
					return errors.Wrapf(err, "failed to execute file %s", e.Filename)
				}
			}

			fName := e.Filename
			if e.IsTest {
				fName += "_test"
			}
			fName += ext
			if len(dir) != 0 {
				fName = filepath.Join(dir, fName)
			}

			if err := writeFile(e.OutFolder, fName, out, isGo); err != nil {
				return err
			}
		}
	}

	return nil
}

func executeSingletonTemplates(e Options) error {

	if err := initOutFolders(e.Templates, e.OutFolder, e.Wipe); err != nil {
		return errors.Wrap(err, "failed to initialize output folders")
	}

	templates, err := ParseTemplates(e.Templates, e.IsTest, e.TemplateFuncs)
	if err != nil {
		return err
	}

	out := templateByteBuffer
	for _, tplName := range templates.Templates() {
		normalized, isSingleton, isGo, usePkg := outputFilenameParts(tplName)
		if !isSingleton {
			continue
		}

		dir, fName := filepath.Split(normalized)
		fName = fName[:strings.IndexByte(fName, '.')]

		out.Reset()

		if isGo {
			imps := importers.Set{
				Standard:   e.ImportNamedSet[DenormalizeSlashes(fName)].Standard,
				ThirdParty: e.ImportNamedSet[DenormalizeSlashes(fName)].ThirdParty,
			}

			pkgName := e.PkgName
			if !usePkg {
				pkgName = filepath.Base(dir)
			}
			if !e.NoGeneratedHeader {
				writeFileDisclaimer(out)
			}
			writePackageName(out, pkgName)
			writeImports(out, imps)
		}

		if err := executeTemplate(out, templates.Template, tplName, e.Data); err != nil {
			return err
		}

		if err := writeFile(e.OutFolder, normalized, out, isGo); err != nil {
			return err
		}
	}

	return nil
}

// writeFileDisclaimer writes the disclaimer at the top with a trailing
// newline so the package name doesn't get attached to it.
func writeFileDisclaimer(out *bytes.Buffer) {
	_, _ = out.Write(noEditDisclaimer)
}

// writePackageName writes the package name correctly, ignores errors
// since it's to the concrete buffer type which produces none
func writePackageName(out *bytes.Buffer, pkgName string) {
	_, _ = fmt.Fprintf(out, "package %s\n\n", pkgName)
}

// writeImports writes the package imports correctly, ignores errors
// since it's to the concrete buffer type which produces none
func writeImports(out *bytes.Buffer, imps importers.Set) {
	if impStr := imps.Format(); len(impStr) > 0 {
		_, _ = fmt.Fprintf(out, "%s\n", impStr)
	}
}

// writeFile writes to the given folder and filename, formatting the buffer
// given.
func writeFile(outFolder string, fileName string, input *bytes.Buffer, format bool) error {
	var byt []byte
	var err error
	if format {
		byt, err = formatBuffer(input)
		if err != nil {
			return err
		}
	} else {
		byt = input.Bytes()
	}

	path := filepath.Join(outFolder, fileName)
	if err := testHarnessWriteFile(path, byt, 0664); err != nil {
		return errors.Wrapf(err, "failed to write output file %s", path)
	}

	return nil
}

// executeTemplate takes a template and returns the output of the template
// execution.
func executeTemplate(buf *bytes.Buffer, t *template.Template, name string, data interface{}) (err error) {
	defer func() {
		if r := recover(); r != nil {
			err = errors.Errorf("failed to execute template: %s\npanic: %+v\n", name, r)
		}
	}()

	if err := t.ExecuteTemplate(buf, name, data); err != nil {
		return errors.Wrapf(err, "failed to execute template: %s", name)
	}
	return nil
}

func formatBuffer(buf *bytes.Buffer) ([]byte, error) {
	output, err := format.Source(buf.Bytes())
	if err == nil {
		return output, nil
	}

	matches := rgxSyntaxError.FindStringSubmatch(err.Error())
	if matches == nil {
		return nil, errors.Wrap(err, "failed to format template")
	}

	lineNum, _ := strconv.Atoi(matches[1])
	scanner := bufio.NewScanner(buf)
	errBuf := &bytes.Buffer{}
	line := 1
	for ; scanner.Scan(); line++ {
		if delta := line - lineNum; delta < -5 || delta > 5 {
			continue
		}

		if line == lineNum {
			errBuf.WriteString(">>>> ")
		} else {
			fmt.Fprintf(errBuf, "% 4d ", line)
		}
		errBuf.Write(scanner.Bytes())
		errBuf.WriteByte('\n')
	}

	return nil, errors.Wrapf(err, "failed to format template\n\n%s\n", errBuf.Bytes())
}

func getLongExt(filename string) string {
	index := strings.IndexByte(filename, '.')
	return filename[index:]
}

// fileFragments will take something of the form:
// templates/singleton/hello.go.tpl
// templates_test/js/hello.js.tpl
func outputFilenameParts(filename string) (normalized string, isSingleton, isGo, usePkg bool) {
	fragments := strings.Split(filename, string(os.PathSeparator))
	isSingleton = fragments[len(fragments)-2] == "singleton"

	var remainingFragments []string
	for _, f := range fragments[1:] {
		if f != "singleton" {
			remainingFragments = append(remainingFragments, f)
		}
	}

	newFilename := remainingFragments[len(remainingFragments)-1]
	newFilename = strings.TrimSuffix(newFilename, ".tpl")
	newFilename = rgxRemoveNumberedPrefix.ReplaceAllString(newFilename, "")
	remainingFragments[len(remainingFragments)-1] = newFilename

	ext := filepath.Ext(newFilename)
	isGo = ext == ".go"

	usePkg = len(remainingFragments) == 1
	normalized = strings.Join(remainingFragments, string(os.PathSeparator))

	return normalized, isSingleton, isGo, usePkg
}

// initOutFolders creates the folders that will hold the generated output.
func initOutFolders(lazyTemplates []LazyTemplate, outFolder string, wipe bool) error {
	if wipe {
		if err := os.RemoveAll(outFolder); err != nil {
			return err
		}
	}

	newDirs := make(map[string]struct{})
	for _, t := range lazyTemplates {
		// templates/js/00_struct.js.tpl
		// templates/js/singleton/00_struct.js.tpl
		// we want the js part only
		fragments := strings.Split(t.Name, string(os.PathSeparator))

		// Throw away the root dir and filename
		fragments = fragments[1 : len(fragments)-1]
		if len(fragments) != 0 && fragments[len(fragments)-1] == "singleton" {
			fragments = fragments[:len(fragments)-1]
		}

		if len(fragments) == 0 {
			continue
		}

		newDirs[strings.Join(fragments, string(os.PathSeparator))] = struct{}{}
	}

	if err := os.MkdirAll(outFolder, os.ModePerm); err != nil {
		return err
	}

	for d := range newDirs {
		if err := os.MkdirAll(filepath.Join(outFolder, d), os.ModePerm); err != nil {
			return err
		}
	}

	return nil
}
