package core

import (
	"encoding/json"
	"fmt"
	"github.com/pkg/errors"
	"github.com/randallmlough/simmer/data"
	"github.com/randallmlough/simmer/database"
	"golang.org/x/mod/modfile"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	pathRegex *regexp.Regexp

	noEditDisclaimerFmt = `// Code generated by Simmer%s(https://github.com/randallmlough/simmer). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

`
)

func init() {
	var initError error
	pathRegex, initError = regexp.Compile(`src\/(.*)`)
	if initError != nil {
		fmt.Println("could not compile the path regex")
	}
}

type Config struct {
	DBConfig   *database.Config `json:"database" yaml:"database"`
	Migrations string
	Tasks      map[string]*Options `json:"tasks" yaml:"tasks"`

	Debug bool `toml:"debug,omitempty" json:"debug,omitempty" yaml:"debug,omitempty"`

	NoEditDisclaimer []byte
	Verbose          bool   `json:"verbose" yaml:"verbose"`
	Version          string `toml:"-" json:"-" yaml:"-"`

	Models         data.Options `json:"models" yaml:"models"`
	Schema         StringList   `yaml:"schema,omitempty"`
	RootImportPath string       `json:"root_import_path" yaml:"root_import_path"`
}

func LoadConfig(pathToConfigFile string) (*Config, error) {
	config, err := ReadConfigFile(pathToConfigFile)
	if err != nil {
		return nil, err
	}
	if len(config.Version) > 0 {
		config.NoEditDisclaimer = []byte(
			fmt.Sprintf(noEditDisclaimerFmt, " "+config.Version+" "),
		)
	}

	importPath, err := rootImportPath()
	if err != nil {
		return nil, err
	}
	config.RootImportPath = importPath
	return config, nil
}

// Load returns Configuration struct
func ReadConfigFile(path string) (*Config, error) {
	ext := filepath.Ext(path)
	switch ext {
	case ".json", ".yaml", ".yml":
	default:
		return nil, errors.New("unsupported file. Config only supports: .json .yaml .yml")
	}
	bytes, err := readFileEnvParsing(path)
	if err != nil {
		return nil, errors.Wrap(err, "error reading config file")
	}
	var cfg = new(Config)
	switch ext {
	case ".json":
		if err := json.Unmarshal(bytes, cfg); err != nil {
			return nil, errors.Wrap(err, "unable to decode into struct")
		}
	case ".yaml", ".yml":
		if err := yaml.Unmarshal(bytes, cfg); err != nil {
			return nil, errors.Wrap(err, "unable to decode into struct")
		}
	}
	return cfg, nil
}

func readFileEnvParsing(path string) ([]byte, error) {
	confContent, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	// expand environment variables
	return []byte(os.Expand(string(confContent), ParseEnv)), nil
}

func ParseEnv(key string) string {
	parts := strings.Split(key, ":-")
	if env, ok := os.LookupEnv(parts[0]); ok {
		return env
	} else if len(parts) > 1 {
		return parts[1]
	}
	return ""
}

func rootImportPath() (string, error) {
	projectPath, err := GetWorkingPath()
	if err != nil {
		// TODO: adhering to your original error handling
		//  should consider doing something here rather than continuing
		//  since this step occurs during generation, panicing or fatal error should be okay
		return "", fmt.Errorf("error while getting working directory %w", err)
	}
	if hasGoMod(projectPath) {
		modulePath, err := getModulePath(projectPath)
		if err != nil {
			// TODO: adhering to your original error handling
			//  should consider doing something here rather than continuing
			//  since this step occurs during generation, panicing or fatal error should be okay
			return "", fmt.Errorf("error while getting module path %w", err)
		}
		return modulePath, nil
	}

	return gopathImport(projectPath), nil
}

// getWorkingPath gets the current working directory
func GetWorkingPath() (string, error) {
	wd, err := os.Getwd()
	if err != nil {
		return "", err
	}
	return wd, nil
}
func hasGoMod(projectPath string) bool {
	filePath := path.Join(projectPath, "go.mod")
	return FileExists(filePath)
}

func FileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

func getModulePath(projectPath string) (string, error) {
	filePath := path.Join(projectPath, "go.mod")
	file, err := ioutil.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("error while trying to read go mods path %w", err)
	}

	modPath := modfile.ModulePath(file)
	if modPath == "" {
		return "", fmt.Errorf("could not determine mod path \n")
	}
	return modPath, nil
}

func gopathImport(dir string) string {
	return strings.TrimPrefix(pathRegex.FindString(dir), "src/")
}

type StringList []string

func (a *StringList) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var single string
	err := unmarshal(&single)
	if err == nil {
		*a = []string{single}
		return nil
	}

	var multi []string
	err = unmarshal(&multi)
	if err != nil {
		return err
	}

	*a = multi
	return nil
}

func (a StringList) Has(file string) bool {
	for _, existing := range a {
		if existing == file {
			return true
		}
	}
	return false
}
